<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta http-equiv="cache-control" content="no-cache">
<meta http-equiv="expires" content="0">
<meta http-equiv="pragma" content="no-cache">
  <title>WW2 Visualization</title>
  <script src="http://d3js.org/d3.v3.min.js"></script>
  <script src="http://d3js.org/queue.v1.min.js"></script>
  <script src="http://d3js.org/topojson.v1.min.js"></script>
  <script src="datamaps.world.min.js"></script> <!-- documentation https://github.com/markmarkoh/datamaps -->
  <!-- Slider stylesheet -->
  <link rel="stylesheet" href="slider.css">
</head>

<body>

<div id="map"></div>

Bubbles: <input type="checkbox" onchange="toggleBubbles();" checked /><br />
<button onclick="resetZoom();">Reset zoom</button>


<script>


var margin = {top: 50, right: 50, bottom: 50, left: 50},
    width = 960 - margin.left - margin.right,
    height = 660 - margin.top - margin.bottom;

var bubble_map, dataset, battles;

d3.json("./data.json", function(err, data) {
    dataset = data;
    d3.json("./battles.json?"+ Math.floor(Math.random() * 1000), function(err, data2) {
        if(err) console.log(err);
        battles = data2;
        build_map();
    })
});

var build_map = function() {
    bubble_map = new Datamap({
        height: height,
        width: width,
        projection:"mercator",
        geographyConfig: {
            dataUrl: './topotest.json?'+ Math.floor(Math.random() * 1000),
            popupOnHover: true,
            highlightOnHover: true,
            popupTemplate: function(geo, data) {
                var n = geo.properties.name;
                return '<div class="hoverinfo">'+
                    '<strong>' + geo.properties.name +'</strong><br />'+
                    'civ_max: ' + (dataset[n] ? dataset[n].civ_max : 'No Data')  +
                    '</div>';
            }
        },
        setProjection: function(element, options) {
            var projection, path;
            projection = d3.geo.mercator()
                .scale(960/2)
                .translate([460, 800]);
            path = d3.geo.path()
                .projection( projection );

            return {path: path, projection: projection};
        },
        scope: 'cshapes',
        element: document.getElementById("map"),
        fills: {
            defaultFill: '#ABDDA4',
            Attacker: 'red',
            Defender: 'blue',
            Axis:'purple',
            Allied:'yellow'
        },
        done: function(datamap) {
            datamap.svg.call(d3.behavior.zoom().on("zoom", redraw));
            function redraw() {
                datamap.svg.selectAll("g").attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
            };
        }
    });
    bubble_map.bubbles(battle_map(), {
      popupTemplate: bubble_popup
    });
};
var bubblesShow = true;
var bubble_popup = function(geo, data) {
    bubble_map.updateChoropleth(null, {reset: true});
    var arr = [];
    data.obj.participants.axis.forEach(function(c) {
        var obj = {};
        obj[c] = {fillKey:'Axis'};
        bubble_map.updateChoropleth(obj);
        arr.push({
            origin: data.obj.location,
            destination: c,
            strokeColor: 'red'
        });
    });
    data.obj.participants.allied.forEach(function(c) {
        var obj = {};
        obj[c] = {fillKey:'Allied'};
        bubble_map.updateChoropleth(obj);
        arr.push({
            origin: data.obj.location,
            destination: c,
            strokeColor: 'blue'
        });
    });
    bubble_map.arc(arr, {strokeWidth: 2, arcSharpness: 1.4});
    return '<div class="hoverinfo">Name:' + data.obj.name + ' Start Date ' + data.obj.start_date + ' by the '  + data.country + '';
};
var bubbles = [];
var battle_map = function() {
    var my_date = function(d) {
        var sp = d.split("-");
        return new Date(sp[2], sp[1] - 1, sp[0]);
    }
    bubbles = battles.reduce(function(a, b) {
        var sd = my_date(b.start_date),
            ed = my_date(b.end_date);
        if(ed < endingValue && sd > startingValue) {
            a.push({
                radius: b.casualities/80000,
                fillKey:'Attacker',
                latitude: b.location.latitude,
                longitude: b.location.longitude,
                obj: b
            });
        }
        return a;
    }, []);
    return bubbles;
}

var toggleBubbles = function() {
    if(bubblesShow) {
        bubble_map.bubbles([]);
        bubblesShow = false;
    } else {
        bubble_map.bubbles(bubbles, {popupTemplate: bubble_popup });
        bubblesShow = true;
    }
};

var resetZoom = function () {
    bubble_map.svg.selectAll("g").attr("transform", "translate(0,0)scale(1.0)");
};


var redrawBubbles = function() {
    bubble_map.bubbles(battle_map(), {popupTemplate: bubble_popup });
};



//
formatDate = d3.time.format("%b %d %Y");

// Time scale funtion
var timeScale = d3.time.scale()
  .domain([new Date('1939-01-01'),new Date('1945-12-31')])
  .range([0,width])
  .clamp(true);

// init values
var sliderStartDate = timeScale(new Date('1940-11-3'));

startingValue = new Date('1939-01-01');
endingValue = new Date('1942-03-20');
// brush
var brush = d3.svg.brush()
  .x(timeScale)
  .extent([startingValue,endingValue])
  //.on("brushstart", brushstart)
  .on("brush", brushed)
  .on("brushend", redrawBubbles);

// slider svg
var sliderHeight = 100;

var sliderSvg = d3.select("body").append("svg")
  .attr("width", width + margin.left + margin.right )
  .attr("height", sliderHeight + margin.top + margin.bottom)
  .append("g")
  // classic transform to position g
  .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

sliderSvg.append("g")
  .attr("class", "x axis")
  // put in middle of screen
  .attr("transform", "translate(0," + sliderHeight / 2 + ")")
  // inroduce axis
  .call(d3.svg.axis()
    .scale(timeScale)
    .orient("bottom")
    .tickFormat(function(d) {
      return formatDate(d);
    })
    .tickSize(0)
    .tickPadding(12)
    .tickValues([timeScale.domain()[0], timeScale.domain()[1]]))
    .select(".domain")
    .select(function() {
      return this.parentNode.appendChild(this.cloneNode(true));
    })
    .attr("class", "halo");

var slider = sliderSvg.append("g")
  .attr("class", "slider")
  .call(brush);

slider.select(".background")
  .attr("height", sliderHeight);

slider.selectAll(".resize")
  .append("path")
  .attr("d", "M 0 -20 V 20")

slider.selectAll("rect")
    .attr("height", sliderHeight);

var handleLeft = slider.append("g")
  .attr("class", "handle")

handleLeft.append("path")
  .attr("transform", "translate(0," + sliderHeight / 2 + ")")
  .attr("d", "M 0 -20 V 20")

handleLeft.append('text')
  .text(startingValue)
  .attr("transform", "translate(" + (-18) + " ," + (sliderHeight / 2 - 25) + ")");

var handleRight = slider.append("g")
  .attr("class", "handle")

handleRight.append("path")
  .attr("transform", "translate(0," + sliderHeight / 2 + ")")
  .attr("d", "M 0 -20 V 20")

handleRight.append('text')
  .text(endingValue)
  .attr("transform", "translate(" + (-18) + " ," + (sliderHeight / 2 - 25) + ")");

slider
  .call(brush.event)

function brushed() {
  var value = brush.extent();

  handleLeft.attr("transform", "translate(" + timeScale(value[0]) + ",0)");
  handleLeft.select('text').text(formatDate(value[0]));
  startingValue = value[0];

  handleRight.attr("transform", "translate(" + timeScale(value[1]) + ",0)");
  handleRight.select('text').text(formatDate(value[1]));
  endingValue = value[1];
}

</script>
</body>
</html>
